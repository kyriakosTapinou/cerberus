amr.restart = IDEAL_EB_CONDUCTING_GEM.chk79068 # third restart after crash, change cfl from 1e-2 to 1e-3
#IDEAL_EB_CONDUCTING_GEM.chk22249 # second restart changed from 1e-2 to 5e-2
# IDEAL_EB_CONDUCTING_GEM.chk19140 # first restart changed cfl from 0.5e-3 to 1e-2

#======== AMREX ==========
amrex.fpe_trap_invalid=1
amrex.fpe_trap_zero=1
fpe_trap_overflow=1
amr.v = 0

# ======== TIME ==========
max_step  = 10000000
stop_time = 400. 

# ======== DOMAIN ==========
geometry.is_periodic = 1 0 
geometry.coord_sys   = 0  # 0 => cart, 1 => RZ  2=>spherical

# lo. res.
geometry.prob_lo     =    -12.8 -6.4
geometry.prob_hi     =     12.8  6.4
amr.n_cell           =     32 16

# ======== LOAD BALANCE ==========
amr.loadbalance_with_workestimates = 1
amr.loadbalance_level0_int = 10

# ======== GRID ==========
amr.max_level       = 2        # maximum level number allowed
amr.ref_ratio       = 2 2 2 2 2 2 2 2 2 # refinement ratio
amr.regrid_int      = 2 2 2 2 2 2 2 2 2 # how often to regrid
amr.blocking_factor = 8
amr.max_grid_size   = 32
amr.n_error_buf     = 4 4 4 4 4 4 4 4 4 # number of buffer cells in error est
amr.grid_eff        = 0.75     # what constitutes an efficient grid
amr.subcycling_mode = Auto # time sub-cycling (Auto, None, Manual, Optimal)

# ======== GEOMETRY ==========
eb2.small_volfrac = 1e-10

# ======== PARTICLES ==========
particles.do_particles = 1
particles.v = 0

# ======== OUTPUT ==========

# CHECKPOINT FILES
amr.checkpoint_files_output = 1
amr.check_file              = IDEAL_EB_CONDUCTING_GEM.chk    # root name of checkpoint file
amr.check_int               = 0    # number of timesteps between checkpoints
amr.check_per               = 1e-0

# PLOTFILES
amr.plot_files_output = 1
amr.plot_file         = IDEAL_EB_CONDUCTING_GEM.plt     # root name of plotfile
amr.plot_int          = 0      # number of timesteps between plotfiles
amr.plot_per          = 5e-1

# ======== PROBLEM DESCRIPTION ==========
# Note that the problem description is defined as a lua script
# Everything within the double quotes "..." must conform to lua standards
# Note that any strings should therefore be defined by single quotes '...'

mfp.lua = "
-- ========== SOLVER SETTINGS ========
verbosity = 1
cfl = 1e-3 --0.00000000001 --1. b source only --0.5
cfl_viscous = 1e-0 --0.000001
do_CTU = 1 -- turn on/off corner transport upwind 
do_face_sources = 1

-- =========  DEFINE PROBLEM  =========
hydro_mass = {0.04, 1.0}
hydro_charge = {-1.0, 1.0}
hydro_gamma = {5/3.0, 5/3.0}

--dimensional parameters
B0_dim = 1e-8 --1e30 --  T
n0_dim = 1e6 -- 1/m3
mu0_dim = 1.25663706e-6 
ep0_dim = 8.85418782e-12
kb = 1.38064852e-23
c_dim = 299792458.0/150 --m/s
q_ref = 1.60217662e-19 -- Coulombs
m_ref = 1.6726219e-27 -- kg 

-- PROBLEM CONSTANTS
B0 = 0.1
n0 = 1 -- 1000. --ref_density/ref_mass
p_scale = 1
phi0 = 0.1*B0 -- some perturbation to the B fields 
lx = 25.6
ly = 12.8
mu0 = 1 --permeability of free space (assume 1 for nondimensionalised)
ep0 = 1 --permeability of free space (assume 1 for nondimensionalised)

mi = hydro_mass[2]
me = hydro_mass[1]

gamma = hydro_gamma[1]

lambda = 0.5 -- current sheet thickness

ref_mass = m_ref --proton mass -- 1.

omega_ci = hydro_charge[2]*q_ref*B0_dim/hydro_mass[2]/m_ref

omega_pi = math.sqrt(n0_dim*hydro_charge[2]*q_ref*hydro_charge[2]*q_ref/ep0_dim/hydro_mass[2]/ref_mass) --rad/s

--[[
print('\nDimensional omega_ci')
print(omega_ci)
print('\nDimensional omega_pi')
print(omega_pi)
--]]

-- REFERENCE VALUES 
ref_length = c_dim/omega_pi --ion inertial length scale--1.
ref_nd = n0_dim/n0
ref_density = n0_dim/n0*ref_mass --representative of space plasma -- 1.
ref_lightspeed = c_dim 
ref_B = B0_dim/B0
ref_velocity = ref_B/math.sqrt(mu0_dim*ref_mass*ref_nd)
ref_pressure = ref_nd*ref_mass*ref_velocity*ref_velocity

skin_depth_dim = c_dim/omega_pi

lightspeed = c_dim/ref_velocity --10 
beta = 2*mu0_dim*ref_nd*ref_mass*ref_velocity*ref_velocity/ref_B/ref_B; --B0_dim/B0_dim -- 1
skin_depth = skin_depth_dim/ref_length --10
Larmor = math.sqrt(beta/2.)*skin_depth;

--[[
print('\ndimensional skin depth')
print(skin_depth_dim)
print('\ndimensional reference velocity')
print(ref_velocity)
--]]

-- ======== Helper Functions =========
function sech2(x)
  --return 2/(math.exp(x) - math.exp(-x)) * 2/(math.exp(x) - math.exp(-x)) 
  return 1/math.cosh(x)/math.cosh(x)
end 

-- ======== EM FUNCTIONS ==========
function Bx_init(dat)
  x = dat['x']
  y = dat['y']
  return B0*math.tanh(y/lambda) - phi0*math.pi/ly*math.cos(2*math.pi*x/lx)*math.sin(math.pi*y/ly)
end

function By_init(dat)
  x = dat['x']
  y = dat['y']
  return phi0*2*math.pi/lx*math.sin(2*math.pi*x/lx)*math.cos(math.pi*y/ly)
end

function jz_init(dat)
  x = dat['x']
  y = dat['y']
  return B0/mu0/lambda*sech2(y/lambda)
end

-- ======== FLUID FUNCTIONS ==========
function ion_density(dat)
  x = dat['x']
  y = dat['y']
  return n0*mi*(sech2(y/lambda) + 1./5.)
end

function ele_density(dat)
  x = dat['x']
  y = dat['y']
  return n0*me*(sech2(y/lambda) + 1./5.)
end

function ion_pressure(dat)
    x = dat['x']
    y = dat['y']
    return p_scale*5./12.*B0*B0*ion_density(dat)/(mu0*mi*n0*(gamma-1))
end

function ele_pressure(dat)
    x = dat['x']
    y = dat['y']
    return p_scale*1./12.*B0*B0*ele_density(dat)/(mu0*me*n0*(gamma-1))
end

function v_z(dat)
    x = dat['x']
    y = dat['y']
    n_ele = ele_density(dat)/hydro_mass[1]
    n_ion = ion_density(dat)/hydro_mass[2]
    jz_val = jz_init(dat) 
    return jz_val/(hydro_charge[2]*n_ion - hydro_charge[1]*n_ele)
end

function v_z_ele(dat)
  return -v_z(dat)
end

function v_z_ion(dat)
  return v_z(dat)
end

-- === DEFINE STATES ===
print('\nat x,y=1')
dat_eg = {x=1, y=1}

n_ele = ele_density(dat_eg)/hydro_mass[1]*ref_nd -- dimensional
Te = ele_pressure(dat_eg)*ref_pressure/n_ele/kb -- dimensional
n_ion = ion_density(dat_eg)/hydro_mass[2]*ref_nd -- dimensional
Ti = ion_pressure(dat_eg)*ref_pressure/n_ion/kb -- dimensional
Te_nond = ele_pressure(dat_eg)/(ele_density(dat_eg)/hydro_mass[1]) 
Ti_nond = ion_pressure(dat_eg)/(ion_density(dat_eg)/hydro_mass[2])
--[[
print('\nNon-dimensional number densities')
print(n_ele/ref_nd, n_ion/ref_nd)
print('\nDimensional number densities')
print(n_ele, n_ion)
print('\nNon-dimensiona temperatures')
print(Te_nond, Ti_nond )
print('\nDimensiona temperatures')
print(Te, Ti)
print('\nDimensional Collision time scales, t_e, t_i')
--]]
t_e = 6*math.sqrt(2)*math.pow(math.pi, 3./2.)*ep0_dim*ep0_dim*math.sqrt(ref_mass/1836)*math.pow(kb*Te, 3./2.)/(10*math.pow(q_ref, 4)*n_ele)
t_i = 12*math.pow(math.pi, 3./2.)*ep0_dim*ep0_dim*math.sqrt(mi*ref_mass)*math.pow(kb*Ti, 3./2.)/(10*math.pow(q_ref, 4)*n_ion)
print(t_e, t_i)

--print('\nDimensional ion and electron accoustic speed, c_si, c_se')
c_si = math.sqrt((hydro_gamma[1]*kb*Te + hydro_gamma[2]*kb*Ti)/mi/ref_mass)
c_se = math.sqrt(hydro_gamma[1]*kb*Te/mi/ref_mass)
--print(c_si, c_se)

print('\nRatio of sound speeds to ref_lightspeed')
print(ref_lightspeed/c_si, ref_lightspeed/c_se)
print(hydro_charge[1], hydro_charge[2])
omega_ci_nd = hydro_charge[2]*B0/hydro_mass[2]/Larmor
omega_pi_nd = math.sqrt(n0*hydro_charge[2]*hydro_charge[2]/hydro_mass[2]/Debye/Debye) 
--print('\nNondimensional cyclotron and plasma freq', omega_ci_nd, omega_pi_nd)
print('\nRequired non-dimensional simulation time', 400/omega_ci_nd)

states = {
    ions = {
        type='hydro',
        mass=hydro_mass[2],  
        charge=hydro_charge[2], 
        gamma=hydro_gamma[2], 
        reconstruction='minmod',
        flux='HLLE',
        refine_grad_threshold={rho=0.1},
        value={
            rho=ion_density,
            p=ion_pressure,
            z_vel=v_z_ion,
        },
        viscosity={mu0=1.7894e-5, T0=273.11, BT=1, cfl=cfl_viscous , type='BraginskiiIon'},
    },

    electrons = {
        type='hydro',
        mass=hydro_mass[1],  
        charge=hydro_charge[1], 
        gamma=hydro_gamma[1], 
        reconstruction='vanLeer',
        flux='HLLE',
        refine_grad_threshold={rho=0.1},
        value={
            rho=ele_density,
            p=ele_pressure,
            z_vel=v_z_ele,
        },
        viscosity={mu0=1.7894e-5, T0=273.11, BT=1, cfl=cfl_viscous, type='BraginskiiEle'},
    },

    field = {
        type='field',
        reconstruction='O6',
        flux='RankineHugoniot',
        --project_divergence=1, 
        --div_transport=1,
        --damping_ratio=1,
        value={
               x_B=Bx_init, 
               y_B=By_init,
              },
--        eb_divergence={ --- finite volume divergence calc / merge quote generally end quote better 
--          type='redistribute',
--          strategy='volume',
--        },
--        bc={
--            y={lo={fill_B_bc='asymmetry',
--                   fill_D_bc='asymmetry', 
--                  },
--               hi={fill_B_bc='asymmetry',
--                   fill_D_bc='asymmetry',
--                  },
--              },
--        },
    }
}

sources = {
    two_fluid={
        solver='explicit',
        sources={
            plasma={
                'ions', 'electrons', 'field', type='plasma5',
              },
            braginskii={'ions', 'electrons', 'field', type='braginskii',
                       reconstruction='centre',
            },
            --current={'field', type='current', z=jz_init,
            --        },
        },
    }, 
}

-- === Geometry ===
refine_cutcells = 1

-- collection = {{{x_lo, x_hi},{y_lo,y_hi}}, ... }
function make_rectangles(x,y,collection)
  local d, d1, dx, dy, dx_, dy_
  local coords = {x,y}

  for i, v in ipairs(collection) do
    dx = math.max(coords[1] - v[1][2], v[1][1] - coords[1])
    dy = math.max(coords[2] - v[2][2], v[2][1] - coords[2])

    dx_ = math.max(dx, 0.0)
    dy_ = math.max(dy, 0.0)

    d1 = math.sqrt(dx_*dx_ + dy_*dy_) + math.min(0.0, math.max(dx, dy))

    if (i == 1) then
      d = d1
    else 
      d = math.min(d, d1)
    end
  end

  return d
end 

function lowerBoundary(x,y)
  local rect = {
    {{-12.9, 12.9},{-6.5, -6.3}},
  }
  return make_rectangles(x,y,rect)
end

function upperBoundary(x,y)
  local rect = {
    {{-12.9, 12.9},{6.3, 6.5}},
  }
  return make_rectangles(x,y,rect)
end

embedded_boundaries={
  upperBoundary={
        geom=upperBoundary, 
        bcs={field={type='conductor'},
      },
      boolean_operation='and',
      inside=0,
  },
  lowerBoundary={
        geom=lowerBoundary, 
        bcs={field={type='conductor'},
      },
      boolean_operation='or',
      inside=0,
  },
}

-- === PLOTTING ===
function outside(dat)
  if ((dat['vfrac-electrons'] == 0.0) or (dat['vfrac-ions'] == 0.0)) then
      return true
  else 
      return false
  end
end

function charge_density(dat)

  if (outside(dat)) then
      return 0.0
  end

  local cd_e = dat['charge-electrons']*dat['rho-electrons']/dat['mass-electrons']
  local cd_i = dat['charge-ions']*dat['rho-ions']/dat['mass-ions']
  
  return (cd_e + cd_i)*(dat['Larmor']/dat['Debye']^2)
end

function div_D(dat)

  if (outside(dat)) then
      return 0.0
  end
  
  return dat['x_D-field-dx'] + dat['y_D-field-dy']
end

function err(dat)
  local cd = charge_density(dat)
  local div = div_D(dat)
  return cd - div
end

plot={
      variables={
      'all',
      'vfrac-ions',
      'vfrac-electrons',
      'vfrac-field',
      'x_D-field-dx',
      'y_D-field-dy',
      'x_B-field-dx',
      'y_B-field-dy',
      }, 
      functions={
      charge_density,
      div_D
      }
}

"
